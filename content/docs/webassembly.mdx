---
title: "WebAssembly"
description: "Running WebAssembly modules in Elide"
date: "2025-11-20"
---

# WebAssembly

Run WebAssembly modules with full WASI support in Elide.

## Overview

Elide provides first-class WebAssembly support with:

- WASI preview 1 implementation
- File system access
- Environment variables
- Standard input/output
- High performance execution

## Loading WASM Modules

### Basic Loading

```javascript
// Load WASM module
const module = await WebAssembly.instantiate(
  await Elide.readFile('module.wasm')
)

// Call exported functions
const result = module.instance.exports.add(5, 3)
console.log(result) // 8
```

### With Imports

```javascript
const imports = {
  env: {
    log: (value) => console.log(value),
    memory: new WebAssembly.Memory({ initial: 1 })
  }
}

const module = await WebAssembly.instantiate(
  await Elide.readFile('module.wasm'),
  imports
)
```

## WASI Support

### Running WASI Modules

```javascript
const wasi = new WASI({
  args: process.argv,
  env: process.env,
  preopens: {
    '/': '.'
  }
})

const module = await WebAssembly.instantiate(
  await Elide.readFile('module.wasm'),
  wasi.getImportObject()
)

wasi.start(module.instance)
```

### File System Access

WASI modules can access the file system:

```rust
// Rust code (compiles to WASM)
use std::fs;

fn main() {
    let content = fs::read_to_string("data.txt")
        .expect("Failed to read file");
    println!("{}", content);
}
```

## Compiling to WebAssembly

### Rust

```bash
# Install target
rustup target add wasm32-wasi

# Compile
cargo build --target wasm32-wasi --release
```

```rust
// src/main.rs
#[no_mangle]
pub extern "C" fn add(a: i32, b: i32) -> i32 {
    a + b
}
```

### C/C++

```bash
# Using wasi-sdk
clang --target=wasm32-wasi \
  -o module.wasm \
  module.c
```

```c
// module.c
__attribute__((export_name("add")))
int add(int a, int b) {
    return a + b;
}
```

### AssemblyScript

```typescript
// module.ts
export function add(a: i32, b: i32): i32 {
  return a + b
}
```

```bash
# Compile
asc module.ts -o module.wasm
```

## Memory Management

### Accessing WASM Memory

```javascript
const module = await WebAssembly.instantiate(...)
const memory = module.instance.exports.memory

// Read from memory
const view = new Uint8Array(memory.buffer)
const data = view.slice(0, 100)

// Write to memory
const text = new TextEncoder().encode("Hello")
view.set(text, 0)
```

### Memory Growth

```javascript
const memory = new WebAssembly.Memory({
  initial: 1,  // 64KB pages
  maximum: 10
})

// Grow memory
memory.grow(5) // Add 5 pages (320KB)
```

## Performance

WebAssembly in Elide is highly optimized:

| Metric | Performance |
|--------|-------------|
| **Startup** | < 1ms |
| **Execution** | Near-native |
| **Memory** | Minimal overhead |

### Benchmarks

| Operation | Native | WASM in Elide |
|-----------|--------|---------------|
| Math operations | 1.0x | 0.95x |
| String processing | 1.0x | 0.90x |
| File I/O | 1.0x | 0.85x |

## Interop with Other Languages

### JavaScript ↔ WASM

```javascript
// Call WASM from JavaScript
const result = wasmModule.exports.process(data)

// Call JavaScript from WASM (via imports)
const imports = {
  env: {
    js_callback: (value) => {
      return value * 2
    }
  }
}
```

### Python ↔ WASM

```python
import polyglot

# Load WASM module
wasm = polyglot.eval(language='wasm', path='module.wasm')

# Call WASM function
result = wasm.add(5, 3)
print(result)  # 8
```

## Use Cases

### 1. Performance-Critical Code

```javascript
// Compute-intensive operations in WASM
const fibonacci = wasmModule.exports.fibonacci(40)
```

### 2. Portable Libraries

```javascript
// Use same WASM module across platforms
const imageProcessor = await loadWASM('image-lib.wasm')
```

### 3. Sandboxed Execution

```javascript
// Run untrusted code safely
const sandbox = await loadWASM('untrusted.wasm', {
  maxMemory: 10 * 1024 * 1024, // 10MB
  maxTime: 1000 // 1 second
})
```

## Debugging WASM

### Source Maps

```bash
# Compile with debug info
cargo build --target wasm32-wasi --release -- -g
```

### Logging

```rust
// Add logging to WASM
#[no_mangle]
pub extern "C" fn debug_log(message: *const u8, len: usize) {
    // Log implementation
}
```

## Best Practices

1. **Minimize memory copies** - Pass pointers when possible
2. **Batch operations** - Reduce boundary crossings
3. **Use appropriate types** - Match WASM types (i32, i64, f32, f64)
4. **Profile first** - Measure before optimizing

## Limitations

Current limitations:

- ⚠️ **Threading**: Limited WASM threads support
- ⚠️ **SIMD**: Partial SIMD support
- ⚠️ **GC proposal**: Not yet supported

## Resources

- [WASI Documentation](https://wasi.dev/)
- [WebAssembly Specification](https://webassembly.github.io/spec/)
- [Rust WASM Book](https://rustwasm.github.io/docs/book/)

## Examples

Check out example WASM modules:

- [Image Processing](/examples/wasm-image)
- [Cryptography](/examples/wasm-crypto)
- [Game Logic](/examples/wasm-game)

