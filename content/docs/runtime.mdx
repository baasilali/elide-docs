---
title: "Runtime"
description: "Deep dive into the Elide runtime and execution engine"
date: "2025-11-19"
---

import { Alert } from '@/components/ui/alert'
import { Badge } from '@/components/ui/badge'

# Elide Runtime

The Elide runtime is a high-performance polyglot execution environment built on GraalVM's Truffle framework. This guide explores its internals and capabilities.

## Runtime Architecture

The runtime consists of several interconnected subsystems:

```
┌─────────────────────────────────────────┐
│         Execution Engine                │
│  Parser → AST → Optimizer → Executor    │
└─────────────────────────────────────────┘
               ↓
┌─────────────────────────────────────────┐
│        Memory Management                │
│  GC, Heap, Stack, Code Cache            │
└─────────────────────────────────────────┘
               ↓
┌─────────────────────────────────────────┐
│         Module System                   │
│  ES Modules, CommonJS, Python, Java     │
└─────────────────────────────────────────┘
               ↓
┌─────────────────────────────────────────┐
│         Intrinsics Layer                │
│  Console, Fetch, FS, Crypto, etc        │
└─────────────────────────────────────────┘
```

## Execution Modes

Elide offers two distinct execution modes, each optimized for different use cases.

### JIT Mode (Just-In-Time)

**Best for:** Development, hot-reload scenarios, dynamic workloads

```bash
elide run app.js
```

**Characteristics:**
- ~50-500ms startup time
- Dynamic code optimization
- Full debugging support
- Higher memory usage (~50-100MB minimum)
- Peak performance after warmup

**When JIT Kicks In:**

```
Cold → Interpreted → Profiled → JIT Compiled → Optimized
 0ms      100ms        1s          5s            10s+
```

### Native Mode (Ahead-of-Time)

**Best for:** Production, serverless, CLI tools, resource-constrained environments

```bash
elide build --native app.js
```

**Characteristics:**
- < 10ms startup time
- No warmup required
- Minimal memory (~10-20MB for simple apps)
- Single binary, no dependencies
- Deterministic performance

## Language Support

### JavaScript/TypeScript

Elide provides full ES2024+ support with V8-compatible APIs.

#### Modern JavaScript Features

```javascript
// Top-level await
const config = await fetch('/config.json').then(r => r.json())

// Private fields
class User {
  #password
  
  constructor(name, password) {
    this.name = name
    this.#password = password
  }
}

// Optional chaining & nullish coalescing
const port = process.env.PORT ?? 3000
const host = config?.server?.host ?? 'localhost'

// BigInt support
const largeNumber = 9007199254740991n + 1n

// Template literals
const html = String.raw`
  <div class="user">
    <h1>${user.name}</h1>
  </div>
`
```

#### Performance Optimizations

The runtime applies several optimizations:

1. **Inline Caching**: Fast property access
2. **Hidden Classes**: Optimize object layouts
3. **Escape Analysis**: Stack allocation when possible
4. **Loop Optimization**: Unrolling, hoisting
5. **Dead Code Elimination**: Remove unused code

### Python Integration

Full CPython-compatible Python via GraalPython.

#### Python Runtime

```python
# Native Python execution
import sys
import json
from datetime import datetime

def process_data(items):
    """Process a list of items"""
    results = []
    for item in items:
        results.append({
            'id': item['id'],
            'processed_at': datetime.now().isoformat(),
            'value': item['value'] * 2
        })
    return results

# Use Python's rich ecosystem
import numpy as np
import pandas as pd

def analyze(data):
    df = pd.DataFrame(data)
    return df.describe().to_dict()
```

#### JavaScript ↔ Python Interop

Seamless data exchange between languages:

```javascript
// Import Python module from JavaScript
const { process_data, analyze } = await import('./processor.py')

// Call Python functions with JavaScript data
const items = [
  { id: 1, value: 100 },
  { id: 2, value: 200 }
]

const processed = await process_data(items)
console.log(processed)

// Pass arrays, objects, primitives - all work!
const stats = await analyze(items)
```

**Zero-copy data sharing:**
- Arrays pass by reference
- Objects share memory
- No serialization overhead

### JVM Languages

Native support for Java, Kotlin, Scala, and other JVM languages.

```java
// Java class
public class Calculator {
    public static int add(int a, int b) {
        return a + b;
    }
}
```

```javascript
// Use from JavaScript
const Calculator = Java.type('Calculator')
const result = Calculator.add(10, 20)
console.log(result) // 30
```

## Memory Management

### Heap Organization

```
┌─────────────────────────────┐
│     Young Generation        │  ← New objects allocated here
│                             │
│  Eden Space | Survivor 0|1  │
├─────────────────────────────┤
│     Old Generation          │  ← Long-lived objects promoted here
│                             │
│  Tenured Space              │
├─────────────────────────────┤
│     Metaspace              │  ← Class metadata
└─────────────────────────────┘
```

### Garbage Collection

Elide supports multiple GC algorithms:

| GC | Latency | Throughput | Use Case |
|----|---------|------------|----------|
| **Serial GC** | Moderate | High | Single-threaded apps |
| **G1 GC** | Balanced | Balanced | Most applications |
| **ZGC** | < 1ms | Good | Low-latency required |
| **Epsilon GC** | N/A | Maximum | Short-lived apps |

#### Choosing a GC

```bash
# Ultra-low latency (< 1ms pauses)
elide run --gc=zgc --gc-max-pause=1ms app.js

# High throughput
elide run --gc=g1 app.js

# No GC (for short-lived apps)
elide run --gc=epsilon app.js
```

### Memory Tuning

```bash
# Set heap size
elide run --memory=2G app.js

# Set young generation size
elide run --memory-young=512M app.js

# Enable detailed GC logging
elide run --gc-log=gc.log app.js
```

## Performance Characteristics

### Startup Time

| Mode | Cold Start | Explanation |
|------|------------|-------------|
| **JIT** | ~50-500ms | Parse + compile + initialize |
| **Native** | ~5-10ms | Pre-compiled, instant |

### Memory Usage

Typical memory footprint:

| Application | JIT Mode | Native Mode |
|-------------|----------|-------------|
| Hello World | ~50MB | ~10MB |
| REST API | ~100MB | ~30MB |
| Full App | ~200MB+ | ~50MB+ |

### HTTP Throughput

Elide's HTTP server performance (Linux, 32 cores):

| Scenario | Requests/sec | Latency (p50) | Latency (p99) |
|----------|--------------|---------------|---------------|
| Hello World | 800K+ | 0.5ms | 2ms |
| JSON API | 400K+ | 1ms | 4ms |
| Database Query | 100K+ | 5ms | 15ms |

<Alert>
  <strong>Benchmark Setup:</strong> AMD EPYC 7713, 64 cores, 256GB RAM, Ubuntu 22.04, using wrk benchmarking tool with 256 connections.
</Alert>

## Module System

### Module Resolution

Elide implements the Node.js module resolution algorithm with extensions.

#### Resolution Order

For `import foo from 'bar'`:

1. **Core modules**: `node:fs`, `@elide/server`
2. **Relative paths**: `./bar`, `../bar`
3. **node_modules**: Search up directory tree
4. **Package exports**: Check package.json exports field

### Supported Formats

```javascript
// ES Modules (.mjs, .js with "type": "module")
import { readFile } from 'node:fs/promises'

// CommonJS (.cjs, .js with "type": "commonjs")
const fs = require('fs')

// TypeScript (.ts, .tsx)
import type { User } from './types'

// JSON
import config from './config.json' with { type: 'json' }

// WebAssembly
const wasm = await WebAssembly.instantiateStreaming(
  fetch('./module.wasm')
)
```

### Module Caching

Modules are cached after first load:

```
First Import:
  Load → Parse → Compile → Cache → Execute

Subsequent Imports:
  Cache Hit → Execute
```

Clear cache programmatically:

```javascript
// Clear specific module
delete require.cache[require.resolve('./module')]

// In native mode, cache is persistent across runs
```

## Intrinsics

Elide provides built-in APIs (intrinsics) that are optimized and secure.

### Console

```javascript
// Standard console methods
console.log('Hello', 'World')
console.error('Error:', error)
console.warn('Warning!')
console.debug('Debug info')

// Timing
console.time('operation')
// ... do work
console.timeEnd('operation')

// Assertions
console.assert(value > 0, 'Value must be positive')

// Tables
console.table([
  { name: 'Alice', age: 30 },
  { name: 'Bob', age: 25 }
])
```

### Fetch API

Standard Web Fetch API:

```javascript
// GET request
const response = await fetch('https://api.example.com/data')
const data = await response.json()

// POST with body
const result = await fetch('https://api.example.com/users', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({ name: 'Alice' })
})

// With timeout
const controller = new AbortController()
setTimeout(() => controller.abort(), 5000)

const response = await fetch(url, {
  signal: controller.signal
})
```

### File System

```javascript
// Read file
const content = await Elide.fs.readFile('./file.txt', 'utf-8')

// Write file
await Elide.fs.writeFile('./output.txt', 'Hello, World!')

// List directory
const files = await Elide.fs.readdir('./directory')

// File stats
const stats = await Elide.fs.stat('./file.txt')
console.log(stats.size, stats.mtime)

// Watch for changes (development mode)
const watcher = Elide.fs.watch('./src', (event, filename) => {
  console.log(`${filename} ${event}`)
})
```

### Crypto

```javascript
// Generate random bytes
const bytes = crypto.getRandomValues(new Uint8Array(32))

// Hash data
const data = new TextEncoder().encode('Hello, World!')
const hash = await crypto.subtle.digest('SHA-256', data)

// Encode to hex
const hashHex = Array.from(new Uint8Array(hash))
  .map(b => b.toString(16).padStart(2, '0'))
  .join('')

// HMAC
const key = await crypto.subtle.generateKey(
  { name: 'HMAC', hash: 'SHA-256' },
  true,
  ['sign', 'verify']
)

const signature = await crypto.subtle.sign(
  'HMAC',
  key,
  data
)
```

## Sandboxing & Security

### Context Isolation

Each execution context is isolated:

```javascript
// Create isolated context
const context = Elide.createContext({
  permissions: {
    fs: ['./data'],      // Only access ./data directory
    net: ['example.com'], // Only connect to example.com
    env: false           // No environment variable access
  },
  memory: '100M',        // Memory limit
  timeout: 5000          // Execution timeout (ms)
})

// Run code in context
const result = await context.eval(`
  // This code runs isolated
  const data = await fetch('https://example.com/api')
  return data.json()
`)
```

### Resource Limits

```javascript
// Set resource limits
Elide.setLimits({
  memory: '512M',      // Maximum heap size
  cpu: 0.5,            // CPU quota (50% of one core)
  threads: 10,         // Max thread count
  files: 100,          // Max open file descriptors
  timeout: 30000       // Max execution time (ms)
})
```

## Debugging & Profiling

### Enable Debugging

```bash
# Enable debugging on port 9229
elide run --inspect=9229 app.js

# Wait for debugger to attach
elide run --inspect-brk=9229 app.js
```

Connect with Chrome DevTools: `chrome://inspect`

### CPU Profiling

```bash
# Generate CPU profile
elide run --cpu-profile app.js

# Output: cpu-profile.cpuprofile (open in Chrome DevTools)
```

### Memory Profiling

```bash
# Generate heap snapshot
elide run --heap-snapshot app.js

# Periodic snapshots
elide run --heap-snapshot-interval=10000 app.js
```

### Performance Metrics

```javascript
// Built-in performance API
const start = performance.now()

// ... do work

const duration = performance.now() - start
console.log(`Operation took ${duration}ms`)

// Mark and measure
performance.mark('start-fetch')
const data = await fetch('/api/data')
performance.mark('end-fetch')

performance.measure('fetch-duration', 'start-fetch', 'end-fetch')

// Get all measurements
const measurements = performance.getEntriesByType('measure')
console.log(measurements)
```

## Next Steps

- **[JavaScript Guide](/docs/javascript)** - JavaScript-specific APIs
- **[TypeScript Guide](/docs/typescript)** - TypeScript features
- **[Python Guide](/docs/python)** - Python integration

<Alert>
  <strong>Performance Tip:</strong> Use native mode for production to get instant startup and minimal memory usage. Use JIT mode during development for fast iteration.
</Alert>
